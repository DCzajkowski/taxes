/* eslint-disable @typescript-eslint/no-explicit-any */

import { assertSafeKey } from '@dilatoapp/helpers/src/check'

export function castArray<T>(value: T): T extends any[] ? T : [T] {
  return (Array.isArray(value) ? value : [value]) as any
}

export function chunk<T>(array: T[], by: number): T[][] {
  const result = []

  for (let i = 0; i < array.length; i += by) {
    result.push(array.slice(i, i + by))
  }

  return result
}

export function clone<TElement>(array: readonly TElement[]): TElement[] {
  return array.slice(0)
}

export function difference<TArray extends readonly any[]>(
  array: TArray,
  differentiator: TArray[number][],
): TArray[number][] {
  return array.filter((item) => !differentiator.includes(item))
}

export function dropWhile<TArray extends any[]>(
  array: TArray,
  predicate: (value: TArray[number], index: number, array: TArray) => boolean,
): TArray {
  let i: number

  for (i = 0; i < array.length; i++) {
    if (!predicate(array[i], i, array)) {
      break
    }
  }

  return array.slice(i) as TArray
}

export function enumerate<TElement>(array: TElement[]): (readonly [number, TElement])[] {
  return array.map((value, i) => [i, value] as const)
}

export function filter<TArray extends any[]>(
  array: TArray,
  predicate: (value: TArray[number], i: number, array: TArray) => boolean,
): TArray {
  return array.filter((value, i) => predicate(value, i, array)) as TArray
}

export function flatMap<TArray extends any[], TValue extends any[]>(
  array: TArray,
  mapper: (value: TArray[number], i: number, array: TArray) => TValue,
): TValue[number][] {
  return array.flatMap((value, i) => mapper(value, i, array))
}

export function first<TElement>(array: readonly TElement[]): TElement | undefined {
  return nth(array, 0)
}

export function groupBy<TArray extends any[], TKey extends string>(
  array: TArray,
  selector: (item: TArray[number]) => TKey,
): Record<TKey, TArray[number][]> {
  const result = {} as Record<TKey, TArray[number][]>

  for (const item of array) {
    const key = selector(item)

    assertSafeKey(key)

    result[key] ??= []
    result[key]?.push(item)
  }

  return result
}

/**
 * Maps an array to an object with keys generated by the selector function. If there are more that one element that
 * returns the same key, the last one is used.
 *
 * @example ```ts
 *   keyBy([{ id: 'a', value: 0 }, { id: 'b', value: 1 }, { id: 'a', value: 2 }], (item) => item.id)
 *   // â†’ { a: { id: 'a', value: 2 }, b: { id: 'b', value: 1 } }
 * ```
 */
export function keyBy<TArray extends any[], TKey extends string>(
  array: TArray,
  selector: (item: TArray[number]) => TKey,
): Record<TKey, TArray[number]> {
  const result: Record<string, TArray[number]> = {}

  for (const item of array) {
    const key = selector(item)

    assertSafeKey(key)

    result[key] = item
  }

  return result
}

export function isArray(arg: unknown): arg is unknown[] {
  return Array.isArray(arg)
}

export function last<TElement>(array: readonly TElement[]): TElement | undefined {
  return nth(array, -1)
}

export function map<TArray extends any[], TValue>(
  array: TArray,
  mapper: (value: TArray[number], i: number, array: TArray) => TValue,
): TValue[] {
  return array.map((value, i) => mapper(value, i, array))
}

export function nth<TElement>(array: readonly TElement[], index: number): TElement | undefined {
  return array[index >= 0 ? index : array.length + index]
}

export function orderBy<TArray extends any[]>(array: TArray, selector: (item: TArray[number]) => any | any[]): TArray {
  function getComparator(aItems: any[], bItems: any[]): 1 | -1 | 0 {
    const [a, ...aRest] = aItems
    const [b, ...bRest] = bItems

    if (a === b) {
      return aRest.length !== 0 && bRest.length !== 0 ? getComparator(aRest, bRest) : 0
    }

    return a > b ? 1 : -1
  }

  return clone(array).sort((a, b) => {
    return getComparator(castArray(selector(a)), castArray(selector(b)))
  }) as TArray
}

export function partition<TArray extends any[], TGuarded>(
  array: TArray,
  predicate: (value: TArray[number], i: number, array: TArray) => value is TGuarded,
): [TGuarded[], Exclude<TArray[number], TGuarded>[]]
export function partition<TArray extends any[]>(
  array: TArray,
  predicate: (value: TArray[number], i: number, array: TArray) => boolean,
): [TArray, TArray]

export function partition<TArray extends any[]>(
  array: TArray,
  predicate: (value: TArray[number], i: number, array: TArray) => boolean,
): [TArray, TArray] {
  const group1 = []
  const group2 = []

  for (let i = 0; i < array.length; i++) {
    const element = array[i]

    if (predicate(element, i, array)) {
      group1.push(element)
    } else {
      group2.push(element)
    }
  }

  return [group1, group2] as [TArray, TArray]
}

export function random<TElement>(array: readonly [TElement, ...TElement[]]): TElement
export function random<TElement>(array: readonly TElement[]): TElement | undefined

export function random<TElement>(array: readonly TElement[]): TElement | undefined {
  return array[Math.floor(Math.random() * array.length)]
}

export function range(startOrEnd: number, maybeEnd?: number, step = 1): number[] {
  if (step === 0) {
    throw new Error('Step of value 0 is not supported.')
  }

  let start: number
  let end: number

  if (maybeEnd === undefined) {
    start = 0
    end = startOrEnd
  } else {
    start = startOrEnd
    end = maybeEnd
  }

  if (end < start && step > 0) {
    step = -step
  }

  const result = []

  for (let i = start; end > start ? i < end : i > end; i += step) {
    result.push(i)
  }

  return result
}

export function reduce<TArray extends any[], TValue, TAccumulator>(
  array: TArray,
  reducer: (accumulator: TAccumulator, value: TArray[number], i: number, array: TArray) => TValue,
  accumulator: TAccumulator,
): TValue[] {
  return array.reduce((accumulator, value, i) => reducer(accumulator, value, i, array), accumulator)
}

export function replace<TElement>(
  array: readonly TElement[],
  predicate: (element: TElement, i: number) => boolean,
  setter: (element: TElement, i: number) => TElement,
): TElement[] {
  const index = array.findIndex(predicate)
  if (index === -1) {
    return clone(array)
  }

  // We know `index` is inside of the array bounds, as we have just found it.
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const element = array[index]!

  return replaceAt(array, index, setter(element, index))
}

export function replaceAt<TElement>(array: readonly TElement[], index: number, value: TElement): TElement[] {
  const result = clone(array)
  result.splice(index, 1, value)
  return result
}

export function sorted<TArray extends string[]>(array: TArray): TArray {
  return clone(array).sort() as TArray
}

export function sumBy<TArray extends any[]>(
  array: TArray,
  extractor: (value: TArray[number], i: number, array: TArray) => number,
): number {
  return array.reduce<number>((result, value, i) => result + extractor(value, i, array), 0)
}

export function uniq<TArray extends any[]>(array: TArray): TArray {
  return Array.from(new Set(array)) as TArray
}

export function uniqBy<TElement>(array: TElement[], reducer: (element: TElement) => number | string): TElement[] {
  return Array.from(new Map(array.map((element) => [reducer(element), element])).values())
}

export function zip<TArray1 extends any[], TArray2 extends any[]>(
  array1: TArray1,
  array2: TArray2,
): [TArray1[number] | undefined, TArray2[number] | undefined][] {
  const length = Math.max(array1.length, array2.length)

  return Array.from({ length }, (_, i) => [array1[i], array2[i]])
}
